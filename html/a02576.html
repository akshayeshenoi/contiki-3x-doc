<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Contiki 3.x: Callback timer</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Contiki 3.x
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('a02576.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Callback timer<div class="ingroups"><a class="el" href="a02853.html">Contiki system</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>The ctimer module provides a timer mechanism that calls a specified C function when a ctimer expires.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga0b183fdc4a1b4be0630a29dfe4fbf3a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02576.html#ga0b183fdc4a1b4be0630a29dfe4fbf3a2">ctimer_init</a> (void)</td></tr>
<tr class="memdesc:ga0b183fdc4a1b4be0630a29dfe4fbf3a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the callback timer library.  <a href="#ga0b183fdc4a1b4be0630a29dfe4fbf3a2">More...</a><br /></td></tr>
<tr class="separator:ga0b183fdc4a1b4be0630a29dfe4fbf3a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27fd17da97a91042bfb1adf1991cc545"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02576.html#ga27fd17da97a91042bfb1adf1991cc545">ctimer_set</a> (struct ctimer *c, clock_time_t t, void(*f)(void *), void *ptr)</td></tr>
<tr class="memdesc:ga27fd17da97a91042bfb1adf1991cc545"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a callback timer.  <a href="#ga27fd17da97a91042bfb1adf1991cc545">More...</a><br /></td></tr>
<tr class="separator:ga27fd17da97a91042bfb1adf1991cc545"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee6c10c997cd9de6d1e82c211503521c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02576.html#gaee6c10c997cd9de6d1e82c211503521c">ctimer_set_with_process</a> (struct ctimer *c, clock_time_t t, void(*f)(void *), void *ptr, struct process *p)</td></tr>
<tr class="memdesc:gaee6c10c997cd9de6d1e82c211503521c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a callback timer.  <a href="#gaee6c10c997cd9de6d1e82c211503521c">More...</a><br /></td></tr>
<tr class="separator:gaee6c10c997cd9de6d1e82c211503521c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ba45d8a9f22b2deb1b91e3ca96be8f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02576.html#ga4ba45d8a9f22b2deb1b91e3ca96be8f2">ctimer_reset</a> (struct ctimer *c)</td></tr>
<tr class="memdesc:ga4ba45d8a9f22b2deb1b91e3ca96be8f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset a callback timer with the same interval as was previously set.  <a href="#ga4ba45d8a9f22b2deb1b91e3ca96be8f2">More...</a><br /></td></tr>
<tr class="separator:ga4ba45d8a9f22b2deb1b91e3ca96be8f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaddaf856390b1f3f572b62def662088aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02576.html#gaddaf856390b1f3f572b62def662088aa">ctimer_restart</a> (struct ctimer *c)</td></tr>
<tr class="memdesc:gaddaf856390b1f3f572b62def662088aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restart a callback timer from the current point in time.  <a href="#gaddaf856390b1f3f572b62def662088aa">More...</a><br /></td></tr>
<tr class="separator:gaddaf856390b1f3f572b62def662088aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga18f970561c46fe308991fcf8002838b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02576.html#ga18f970561c46fe308991fcf8002838b4">ctimer_stop</a> (struct ctimer *c)</td></tr>
<tr class="memdesc:ga18f970561c46fe308991fcf8002838b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop a pending callback timer.  <a href="#ga18f970561c46fe308991fcf8002838b4">More...</a><br /></td></tr>
<tr class="separator:ga18f970561c46fe308991fcf8002838b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f9b6e3e3b86848124f344c8d020ea35"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02576.html#ga2f9b6e3e3b86848124f344c8d020ea35">ctimer_expired</a> (struct ctimer *c)</td></tr>
<tr class="memdesc:ga2f9b6e3e3b86848124f344c8d020ea35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a callback timer has expired.  <a href="#ga2f9b6e3e3b86848124f344c8d020ea35">More...</a><br /></td></tr>
<tr class="separator:ga2f9b6e3e3b86848124f344c8d020ea35"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>The ctimer module provides a timer mechanism that calls a specified C function when a ctimer expires. </p>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga2f9b6e3e3b86848124f344c8d020ea35"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ctimer_expired </td>
          <td>(</td>
          <td class="paramtype">struct ctimer *&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if a callback timer has expired. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>A pointer to the callback timer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Non-zero if the timer has expired, zero otherwise. <pre class="fragment">        This function tests if a callback timer has expired and
        returns true or false depending on its status.</pre> </dd></dl>

<p>Definition at line <a class="el" href="a00946_source.html#l00161">161</a> of file <a class="el" href="a00946_source.html">ctimer.c</a>.</p>

<p>References <a class="el" href="a00951_source.html#l00213">etimer_expired()</a>, <a class="el" href="a00612_source.html#l00083">list_head()</a>, and <a class="el" href="a01872_source.html#l00186">NULL</a>.</p>

</div>
</div>
<a class="anchor" id="ga0b183fdc4a1b4be0630a29dfe4fbf3a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ctimer_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the callback timer library. </p>
<p>This function initializes the callback timer library and should be called from the system boot up code. </p>

<p>Definition at line <a class="el" href="a00946_source.html#l00091">91</a> of file <a class="el" href="a00946_source.html">ctimer.c</a>.</p>

<p>References <a class="el" href="a00612_source.html#l00066">list_init()</a>, <a class="el" href="a01872_source.html#l00186">NULL</a>, and <a class="el" href="a00963_source.html#l00099">process_start()</a>.</p>

<p>Referenced by <a class="el" href="a02008_source.html#l00161">main()</a>, and <a class="el" href="a02330_source.html#l00123">uip_log()</a>.</p>

</div>
</div>
<a class="anchor" id="ga4ba45d8a9f22b2deb1b91e3ca96be8f2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ctimer_reset </td>
          <td>(</td>
          <td class="paramtype">struct ctimer *&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset a callback timer with the same interval as was previously set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>A pointer to the callback timer. <pre class="fragment">        This function resets the callback timer with the same
        interval that was given to the callback timer with the
        ctimer_set() function. The start point of the interval
        is the exact time that the callback timer last
        expired. Therefore, this function will cause the timer
        to be stable over time, unlike the ctimer_restart()
        function.
</pre></td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a02576.html#gaddaf856390b1f3f572b62def662088aa" title="Restart a callback timer from the current point in time. ">ctimer_restart()</a> </dd></dl>

<p>Definition at line <a class="el" href="a00946_source.html#l00125">125</a> of file <a class="el" href="a00946_source.html">ctimer.c</a>.</p>

<p>References <a class="el" href="a00951_source.html#l00192">etimer_reset()</a>, <a class="el" href="a00612_source.html#l00143">list_add()</a>, <a class="el" href="a00964_source.html#l00426">PROCESS_CONTEXT_BEGIN</a>, and <a class="el" href="a00964_source.html#l00440">PROCESS_CONTEXT_END</a>.</p>

<p>Referenced by <a class="el" href="a00912_source.html#l00064">stbroadcast_open()</a>.</p>

</div>
</div>
<a class="anchor" id="gaddaf856390b1f3f572b62def662088aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ctimer_restart </td>
          <td>(</td>
          <td class="paramtype">struct ctimer *&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Restart a callback timer from the current point in time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>A pointer to the callback timer. <pre class="fragment">        This function restarts the callback timer with the same
        interval that was given to the ctimer_set()
        function. The callback timer will start at the current
        time.

        \note A periodic timer will drift if this function is
        used to reset it. For periodic timers, use the
        ctimer_reset() function instead.
</pre></td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a02576.html#ga4ba45d8a9f22b2deb1b91e3ca96be8f2" title="Reset a callback timer with the same interval as was previously set. ">ctimer_reset()</a> </dd></dl>

<p>Definition at line <a class="el" href="a00946_source.html#l00137">137</a> of file <a class="el" href="a00946_source.html">ctimer.c</a>.</p>

<p>References <a class="el" href="a00951_source.html#l00199">etimer_restart()</a>, <a class="el" href="a00612_source.html#l00143">list_add()</a>, <a class="el" href="a00964_source.html#l00426">PROCESS_CONTEXT_BEGIN</a>, and <a class="el" href="a00964_source.html#l00440">PROCESS_CONTEXT_END</a>.</p>

</div>
</div>
<a class="anchor" id="ga27fd17da97a91042bfb1adf1991cc545"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ctimer_set </td>
          <td>(</td>
          <td class="paramtype">struct ctimer *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">clock_time_t&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *)&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a callback timer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>A pointer to the callback timer. </td></tr>
    <tr><td class="paramname">t</td><td>The interval before the timer expires. </td></tr>
    <tr><td class="paramname">f</td><td>A function to be called when the timer expires. </td></tr>
    <tr><td class="paramname">ptr</td><td>An opaque pointer that will be supplied as an argument to the callback function. <pre class="fragment">        This function is used to set a callback timer for a time
        sometime in the future. When the callback timer expires,
        the callback function f will be called with ptr as argument.

        This essentially does ctimer_set_process(c, t, f, ptr, PROCESS_CURRENT());</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="a00024.html#a10">example-multihop.c</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="a00946_source.html#l00099">99</a> of file <a class="el" href="a00946_source.html">ctimer.c</a>.</p>

<p>References <a class="el" href="a00946_source.html#l00106">ctimer_set_with_process()</a>, and <a class="el" href="a00964_source.html#l00402">PROCESS_CURRENT</a>.</p>

<p>Referenced by <a class="el" href="a02041_source.html#l00106">btn_callback()</a>, <a class="el" href="a02352_source.html#l00342">configure()</a>, <a class="el" href="a02360_source.html#l00479">gyro_convert()</a>, <a class="el" href="a00878_source.html#l00137">ipolite_send()</a>, <a class="el" href="a00888_source.html#l00070">packetqueue_enqueue_packetbuf()</a>, <a class="el" href="a00892_source.html#l00119">polite_send()</a>, <a class="el" href="a00876_source.html#l01184">retransmit_callback()</a>, <a class="el" href="a00876_source.html#l00677">retransmit_current_packet()</a>, <a class="el" href="a01605_source.html#l00532">rf_cmd_ieee_rx()</a>, <a class="el" href="a02362_source.html#l00135">select_on_bus()</a>, <a class="el" href="a00876_source.html#l00569">send_queued_packet()</a>, <a class="el" href="a00912_source.html#l00093">stbroadcast_set_timer()</a>, <a class="el" href="a01566_source.html#l00099">uart0_set_input()</a>, and <a class="el" href="a00876_source.html#l00406">update_rtmetric()</a>.</p>

</div>
</div>
<a class="anchor" id="gaee6c10c997cd9de6d1e82c211503521c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ctimer_set_with_process </td>
          <td>(</td>
          <td class="paramtype">struct ctimer *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">clock_time_t&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *)&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct process *&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a callback timer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>A pointer to the callback timer. </td></tr>
    <tr><td class="paramname">t</td><td>The interval before the timer expires. </td></tr>
    <tr><td class="paramname">f</td><td>A function to be called when the timer expires. </td></tr>
    <tr><td class="paramname">ptr</td><td>An opaque pointer that will be supplied as an argument to the callback function. </td></tr>
    <tr><td class="paramname">p</td><td>A pointer to the process the timer belongs to <pre class="fragment">        This function is used to set a callback timer for a time
        sometime in the future. When the callback timer expires,
        the callback function f will be called with ptr as argument.</pre> </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00946_source.html#l00106">106</a> of file <a class="el" href="a00946_source.html">ctimer.c</a>.</p>

<p>References <a class="el" href="a00951_source.html#l00177">etimer_set()</a>, <a class="el" href="a00612_source.html#l00143">list_add()</a>, <a class="el" href="a00964_source.html#l00426">PROCESS_CONTEXT_BEGIN</a>, and <a class="el" href="a00964_source.html#l00440">PROCESS_CONTEXT_END</a>.</p>

<p>Referenced by <a class="el" href="a00946_source.html#l00099">ctimer_set()</a>.</p>

</div>
</div>
<a class="anchor" id="ga18f970561c46fe308991fcf8002838b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ctimer_stop </td>
          <td>(</td>
          <td class="paramtype">struct ctimer *&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stop a pending callback timer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>A pointer to the pending callback timer. <pre class="fragment">        This function stops a callback timer that has previously
        been set with ctimer_set(), ctimer_reset(), or ctimer_restart().
        After this function has been called, the callback timer will be
        expired and will not call the callback function.</pre> </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00946_source.html#l00149">149</a> of file <a class="el" href="a00946_source.html">ctimer.c</a>.</p>

<p>References <a class="el" href="a00951_source.html#l00243">etimer_stop()</a>, <a class="el" href="a00612_source.html#l00240">list_remove()</a>, and <a class="el" href="a01872_source.html#l00186">NULL</a>.</p>

<p>Referenced by <a class="el" href="a02041_source.html#l00106">btn_callback()</a>, <a class="el" href="a02352_source.html#l00342">configure()</a>, <a class="el" href="a00878_source.html#l00174">ipolite_cancel()</a>, <a class="el" href="a00878_source.html#l00126">ipolite_close()</a>, <a class="el" href="a00878_source.html#l00137">ipolite_send()</a>, <a class="el" href="a00888_source.html#l00113">packetqueue_dequeue()</a>, <a class="el" href="a00888_source.html#l00050">packetqueue_init()</a>, <a class="el" href="a00892_source.html#l00135">polite_cancel()</a>, <a class="el" href="a00892_source.html#l00108">polite_close()</a>, <a class="el" href="a00876_source.html#l01184">retransmit_callback()</a>, <a class="el" href="a00876_source.html#l00677">retransmit_current_packet()</a>, <a class="el" href="a00912_source.html#l00115">stbroadcast_cancel()</a>, and <a class="el" href="a00912_source.html#l00064">stbroadcast_open()</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Fri Mar 11 2022 12:06:08 for Contiki 3.x by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
